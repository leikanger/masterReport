\chapter{Implementation Details}

	%\section{Other Aspects, Important for Experimental Comparisons}
		%OG at sectionane under blir gjort til subsection..
	%\section{Other Aspects Important for the Comparison}
		%\subsection{Planned Events}
		%Planned Events (pEstimatedTaskTime vs dEstimatedTaskTime i kvart element).

		\section{Log, for Comparison}
		\label{appendixLogForComparison}
			%For a comparison between the two models, the interesting variables are logged during a run of \emph{auroSim}.
			For a comparison between the two models, the considered variables are logged during the execution of \emph{auroSim}.
			This is done by file streams for each of the compared variables, registered as \emph{private} members of the \emph{i\_auron} class.
			The log with most importance for later sections is the one concerned with the node's depolarization, and will be the presented example of this section.
			%The most important of these is the simulated depolarization of the node.
			%The most important of these is the activation variable(depolarization for $NIM$ and $\kappa$ in $\kappa M$), in addition to the depolarization of the $\kappa M$ node.

%Todo Sjekk om UML for i_auron er merket som pure virtual (det er det i implmentasjonen, siden dette må gjøres ulikt for KM og NIM.
			The public member funtion \emph{writeDepolToLog()} takes care of writing the node's depolarization to the \emph{private} log stream.
			Because the two models represents depolarization differently, this function is pure virtual in \emph{class i\_auron} and overloaded in the derived \emph{s\_auron} and \emph{K\_auron}.
			%\emph{s\_auron} writes the last updated value to the file stream \emph{std::ostream depol\_logFile}, while the \emph{K\_auron} computes the value before writing it.

\begin{lstlisting}
inline virtual void s_auron::writeDepolToLog() const 
{
	// Handle resolution for the depol-logfile:
	static unsigned long uIterationsSinceLastWrite = 0;

	// Unless it is time for writing to log, return.
	if((++uIterationsSinceLastWrite > uNumberOfIterationsBetweenWriteToLog)){
		depol_logFile 	<<time_class::getTime() <<"\t" 
						<<dAktivitetsVariabel <<"; \t #Depolarization\n" ;
		// Reset counter
		uIterationsSinceLastWrite = 0;
	}else{
		return;
	}
}
\end{lstlisting}
			
			The presented source code shows the \emph{writeDepolToLog()} funtion for the \emph{s\_auron} class.
			The log file is implemented with a maximal resolution limit for the log, so that the file log is written every \emph{uNumberOfIterationsBetweenWriteToLog}'th time step.
			This is done to make the execution of the log files simpler to handle for the computer, and is designed to limit the number of log entries to \emph{LOG\_RESOLUTION}, defined for the precompiler.
% this variable is defined at the initiation of the run, and limits the resolution of the log to \emph{LOGG\_RESOLUTION}, defined in the precompiler.
			The log is written as a octave(similar to matlab) executable scrips, and the values are written in the syntax of a matrix.
			The first column represents time and the second hold the depolarization value for that time. 
			In this way, the values can be plotted directly by a plot command in octave.

			The destructor of an \emph{i\_auron} object finalize the log so than it is executable in octave.
			It closes the parenthesis of the matrix, before it plots the result and saves the figure.
			All figures with the footnote \emph{(Generated by \emph{auroSim})} comes from the execution of such log files.
\begin{lstlisting}
i_auron::~i_auron(){
	...
	depol_logFile 	<<"];\n\n"
			<<"plot(data([1:end],1), data([1:end],2), \"@;Depolarization;\");\n"
			<<"title \"Depolarization for auron " <<sNavn <<"\"\n"
			<<"xlabel Time\n" <<"ylabel \"Activity variable\"\n"
			<<"akser=([0 data(end,1) 0 1400 ]);\n"
			<<"print(\'./eps/eps_auron" <<sNavn <<"-depol.eps\', \'-deps\');\n"
			<<"sleep(" <<OCTAVE_SLEEP_ETTER_PLOTTA <<"); "
			;
	depol_logFile.flush();
	depol_logFile.close();
	...
}
\end{lstlisting}
			
			To be certain that all logs are finalized correctly, an automatic destruction of all \emph{i\_auron} objects is conducted before the program terminates.
			This is done in the static member funtion \emph{i\_auron::callDestructorForAllAurons()}, registered at glibc's \emph{atexit(void (*)(void))} function.
			When the program terminates normally, either by returning from main or with an \emph{exit(int)} function, \emph{i\_auron::callDestructorForAllAurons()} is called and the destructor is called for all auron objects.
			%When the program terminates, either normally or after a termination signal, \emph{callDestructorForAllAurons()} calls the destructor of all \emph{i\_auron} objects registered in the static \emph{pAllSensoryAurons} member list.
			%This cause the static member function in \emph{i\_auron} to call the destructor for all aurons registered in the static \emph{i\_auron::pAllAurons} list.
%% 			%%
			%To be certain that all logs are finalized correctly, an automatic destruction of all \emph{i\_auron} objects is done by calling the destructor for all elements in	\emph{i\_auron::pAllAurons}.
			%This is done by the static member funtion \emph{i\_auron::callDestructorForAllAurons()}.
% Kommenterer ut:
%\begin{lstlisting} 
%while( ! i_auron::pAllAurons.empty() )
%{
%	// deallocate element in pAllAurons from the free store.
% 	delete (*i_auron::pAllAurons.begin());
%	// This also calls its destructor, that removes the pointer from pAllAurons
%}
%\end{lstlisting} 







		\section{The Sensory Neuron} 		%Dersom eg legger det som egen subsubsection, bør eg skrive kvifor! (Det er såpass viktig i seinere eksperiment..)
		\label{appendixSensoryNode}
			The sensory neuron is a simple way of setting up replicable experiments so this group of neurons have received special attention when designing the implementation.
			A sensory neuron can be implemented by eq. \eqref{eqSynapticIntegrationForKANN}, where $\xi_i(t_n)$ represents the sensory input at time $t_n$.
			As long as the sensory neuron does not receive other input and $\xi_i(t_n)$ is defined by an algebraic function, it is possible to attain the algebraic solution to the neuron's depolarization.
			%Because the sensory neuron is a simple way of setting up replicable experiments, special attention have been given this subclass of neurons.
			%A sensory neuron can be designed by implementing eq. \eqref{eqSynapticIntegrationForKANN} and letting $\xi_i(t_n)$ represent the sensory input at time $t_n$.
			%As long as the sensory neuron does not receive input from other neurons and $\xi_i(t_n)$ is given as an algebraic function, it is possible to attain the algebraic solution to the neuron's depolarization.
			%As long as the sensory neuron does not receive input from other neurons, it is possible to attain an algebraic solution to the neuron's depolarization by defining $\xi_i(t_n)$ to be an algebraic function. %sensory function.
			%If the sensory neuron is the only neuron in the simulated neural network, this makes it possible to implement the sensory function as an algebraic equation.
	%		The $LIF$ neuron's differential equations defines the node's behaviour, making it possible to compare the simulated depolarization to its algebraic solution.
			%The sensor function is a function pointer

	%TODO Skriv om starten på neste avsnitt! TODO:
			In \emph{auronSim}, a sensory auron is instantiated from a class derived from one of the two auron classes. % \emph{s\_sensory\_auron} and \emph{K\_sensory\_auron}.
			The sensory auron contains two important elements;
			%In this implementation, the sensory function is designed to be a specialized auron element containing two important elements;
				A function pointer to the sensory function and the \emph{static} list \emph{pAllSensoryAurons}.
			To introduce these elements, the constructor of the $NIM$ sensory neuron is presented.
%// *** s_sensory_auron::s_sensory_auron - Constructor for s_sensory_neuron: ***
\begin{lstlisting}
s_sensory_auron::s_sensory_auron( std::string sName_Arg , double (*pFunk_arg)(void) ) : s_auron(sName_Arg)
{
    // Assign the sensory function to the object's function pointer: 
    pSensoryFunction = pFunk_arg;
    // Add a [this]-pointer to the static s_sensory_auron::pAllSensoryAurons:
    pAllSensoryAurons.push_back(this);
}
\end{lstlisting}


			The constructor takes a function pointer as an argument, assigning it to the member pointer function of type \emph{double (*pSensoryFunction)(void)}. 
			It also inserts the node's address as an element in \emph{pAllSensoryAurons}.
%% 			%% TODO Finn ut korleis det skal være med paragraf-skille fra her, og til slutten av section! Skriv om!
			Before \emph{time\_class::doTask()} iterates time, the return value from a call to the dereferenced function \emph{(*pSensoryFunction)()} 
			%When time is iterated by \emph{time\_class::doTask()}, the return value from a call to the dereferenced function of \emph{pSensoryFunction} 
				is sent to the node's \emph{s\_dendrite::newInputSignal(double)} for all elements in the list \emph{pAllSensoryAurons}.
% 			When time is iterated by \emph{time\_class::doTask()}, the sensed value of all elements in the list \emph{pAllSensoryAurons} is updated by sending the value \emph{(*pSensoryFunction)()} 
%				as an argument to \emph{s\_dendrite::newInputSignal(double)}.
			%This makes it relatively effortless to design different experiments where the depolarizing input flow have an algebraic form, enabling a proper analysis of the results.

% TODO Skriv om avslutting på avsnittet: TODO:
			This design makes it possible to execute different experiments relatively effortlessly, and it is simpler to carry out a proper analysis of the accuracy of $\kappa M$ and $NIM$.
			The sensory neuron class is useful when experiments on the accuracy of the two simulation models are designed in chapter \ref{chExperimentalEfficiencyMeasurement}.
			%This will be useful when experiments on the accuracy of the two simulation models are designed and carried out in chap. \ref{chExperimentalEfficiencyMeasurement}.
			%This design makes it relatively effortless to design different experiments with different depolarizing input flows, enabling a proper analysis of the accuracy of the two neuron simulation models, $\kappa M$ and $NIM$.
			
%TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO Skriv recalk-kappa
		\section{Recalculation of $\kappa$}
			%TODO Her skal det stå om implementation of recalculation of kappa, fra FDP.

	\section{An experiment where $\kappa \in [0.5\tau, 2.5\tau]$}
		\label{appendixExperiment3}
		%TODO Lag plot av sensory function where K<T avogtil.
		\begin{figure}[hbt!p]
			\centerline{ \includegraphics[width=1.1\textwidth]{experiment3HalvannenPeriode} }
			\caption[Experiment 3, sensory function $f(t)\in [0.5\tau, 2.5\tau$]]{asdf}
		\end{figure}

