\chapter{Implementation Details}

	%\section{Other Aspects, Important for Experimental Comparisons}
		%OG at sectionane under blir gjort til subsection..
	%\section{Other Aspects Important for the Comparison}
		%\subsection{Planned Events}
		%Planned Events (pEstimatedTaskTime vs dEstimatedTaskTime i kvart element).

		\section{Log, for Comparison}
		\label{appendixLogForComparison}
			%For a comparison between the two models, the interesting variables are logged during a run of \emph{auroSim}.
			For a comparison between the two models, the considered variables are logged during the execution of \emph{auroSim}.
			This is done by file streams for each of the compared variables, registered as \emph{private} members of the \emph{i\_auron} class.
			The log with most importance for later sections is the one concerned with the node's depolarization, and will be the presented example of this section.
			%The most important of these is the simulated depolarization of the node.
			%The most important of these is the activation variable(depolarization for $NIM$ and $\kappa$ in $\kappa M$), in addition to the depolarization of the $\kappa M$ node.

%Todo Sjekk om UML for i_auron er merket som pure virtual (det er det i implmentasjonen, siden dette må gjøres ulikt for KM og NIM.
			The public member funtion \emph{writeDepolToLog()} takes care of writing the node's depolarization to the \emph{private} log stream.
			Because the two models represents depolarization differently, this function is pure virtual in \emph{class i\_auron} and overloaded in the derived \emph{s\_auron} and \emph{K\_auron}.
			%\emph{s\_auron} writes the last updated value to the file stream \emph{std::ostream depol\_logFile}, while the \emph{K\_auron} computes the value before writing it.

\begin{lstlisting}
inline virtual void s_auron::writeDepolToLog() const 
{
	// Handle resolution for the depol-logfile:
	static unsigned long uIterationsSinceLastWrite = 0;

	// Unless it is time for writing to log, return.
	if((++uIterationsSinceLastWrite > uNumberOfIterationsBetweenWriteToLog)){
		depol_logFile 	<<time_class::getTime() <<"\t" 
						<<dAktivitetsVariabel <<"; \t #Depolarization\n" ;
		// Reset counter
		uIterationsSinceLastWrite = 0;
	}else{
		return;
	}
}
\end{lstlisting}
			
			The presented source code shows the \emph{writeDepolToLog()} funtion for the \emph{s\_auron} class.
			The log file is implemented with a maximal resolution limit for the log, so that the file log is written every \emph{uNumberOfIterationsBetweenWriteToLog}'th time step.
			This is done to make the execution of the log files simpler to handle for the computer, and is designed to limit the number of log entries to \emph{LOG\_RESOLUTION}, defined for the precompiler.
% this variable is defined at the initiation of the run, and limits the resolution of the log to \emph{LOGG\_RESOLUTION}, defined in the precompiler.
			The log is written as a Octave(similar to Matlab) executable scrips, and the values are written in the syntax of a matrix.
			The first column represents time and the second hold the depolarization value for that time. 
			In this way, the values can be plotted directly by a plot command in octave.

			The destructor of an \emph{i\_auron} object finalize the log so than it is executable in octave.
			It closes the parenthesis of the matrix, before it inserts commands to plot the result and save the resulting figure.
			All figures with the caption \emph{``(Generated by \emph{auroSim})''} comes from the execution of such log files or modified versions.
\begin{lstlisting}
i_auron::~i_auron(){
	...
	depol_logFile 	<<"];\n\n"
			<<"plot(data([1:end],1), data([1:end],2), \"@;Depolarization;\");\n"
			<<"title \"Depolarization for auron " <<sNavn <<"\"\n"
			<<"xlabel Time\n" <<"ylabel \"Activity variable\"\n"
			<<"akser=([0 data(end,1) 0 1400 ]);\n"
			<<"print(\'./eps/eps_auron" <<sNavn <<"-depol.eps\', \'-deps\');\n"
			<<"sleep(" <<OCTAVE_SLEEP_ETTER_PLOTTA <<"); "
			;
	depol_logFile.flush();
	depol_logFile.close();
	...
}
\end{lstlisting}
			
			To be certain that all logs are finalized correctly, an automatic destruction of all \emph{i\_auron} objects is conducted before the program terminates.
			This is done in the static member function \\ % XXX Bare fordi den var så stygg. Brute-forc'a!
				\emph{i\_auron::callDestructorForAllAurons()}, registered at glib's \emph{atexit(void (*)(void))} function.
			When the program terminates normally, either by returning from main or with an \emph{exit(int)} function, \\ % XXX Bare fordi den var så stygg. Brute-forc'a!
				\emph{i\_auron::callDestructorForAllAurons()} is called, calling the destructor for all constructed auron objects.
			%When the program terminates, either normally or after a termination signal, \emph{callDestructorForAllAurons()} calls the destructor of all \emph{i\_auron} objects registered in the static \emph{pAllSensoryAurons} member list.
			%This cause the static member function in \emph{i\_auron} to call the destructor for all aurons registered in the static \emph{i\_auron::pAllAurons} list.
%% 			%%
			%To be certain that all logs are finalized correctly, an automatic destruction of all \emph{i\_auron} objects is done by calling the destructor for all elements in	\emph{i\_auron::pAllAurons}.
			%This is done by the static member funtion \emph{i\_auron::callDestructorForAllAurons()}.
% Kommenterer ut:
%\begin{lstlisting} 
%while( ! i_auron::pAllAurons.empty() )
%{
%	// deallocate element in pAllAurons from the free store.
% 	delete (*i_auron::pAllAurons.begin());
%	// This also calls its destructor, that removes the pointer from pAllAurons
%}
%\end{lstlisting} 







		\section{The Sensory Neuron} 		%Dersom eg legger det som egen subsubsection, bør eg skrive kvifor! (Det er såpass viktig i seinere eksperiment..)
		\label{appendixSensoryNode}
			The sensory neuron is a simple way of setting up replicable experiments. % so this group of neurons have received special attention when designing the implementation.
			A sensory neuron can be implemented by eq. \eqref{eqSynapticIntegrationForKANN}, where $\xi_i(t_n)$ represents the sensory input at time $t_n$.
			As long as the sensory neuron does not receive other input and $\xi_i(t_n)$ is defined by an algebraic function, it is possible to attain the algebraic solution to the neuron's depolarization.

	%TODO Skriv om starten på neste avsnitt! TODO:
			In \emph{auronSim}, a sensory auron is instantiated from a class derived from one of the two model--specific auron classes. % \emph{s\_sensory\_auron} and \emph{K\_sensory\_auron}.
			The sensory auron contains two important elements;
			%In this implementation, the sensory function is designed to be a specialized auron element containing two important elements;
				A function pointer to the sensory function and the \emph{static} list \emph{pAllSensoryAurons}.
			To introduce these elements, the constructor of the $NIM$ sensory neuron is presented.
%// *** s_sensory_auron::s_sensory_auron - Constructor for s_sensory_neuron: ***
\begin{lstlisting}
s_sensory_auron::s_sensory_auron( std::string sName_Arg , const double& (*pFunk_arg)(void) ) : s_auron(sName_Arg)
{
    // Assign the sensory function to the object's function pointer: 
    pSensoryFunction = pFunk_arg;
    // Add a [this]-pointer to the static s_sensory_auron::pAllSensoryAurons:
    pAllSensoryAurons.push_back(this);
}
\end{lstlisting}


			The constructor takes a function pointer as an argument, assigning it to the member pointer function of type \emph{const double$\&$ (*pSensoryFunction)(void)}. 
			It also inserts the node's address as an element in \emph{pAllSensoryAurons}.
%% 			%% TODO Finn ut korleis det skal være med paragraf-skille fra her, og til slutten av section! Skriv om!
			Before \emph{time\_class::doTask()} iterates time, the return value from a call to the dereferenced function \emph{(*pSensoryFunction)()} 
			%When time is iterated by \emph{time\_class::doTask()}, the return value from a call to the dereferenced function of \emph{pSensoryFunction} 
				is sent to the node's \emph{s\_dendrite::newInputSignal(double)} for all elements in the list \emph{pAllSensoryAurons}.
% 			When time is iterated by \emph{time\_class::doTask()}, the sensed value of all elements in the list \emph{pAllSensoryAurons} is updated by sending the value \emph{(*pSensoryFunction)()} 
%				as an argument to \emph{s\_dendrite::newInputSignal(double)}.
			%This makes it relatively effortless to design different experiments where the depolarizing input flow have an algebraic form, enabling a proper analysis of the results.

% TODO Skriv om avslutting på avsnittet: TODO:
			This design makes it possible to execute different experiments relatively effortlessly, and it is simpler to carry out a proper analysis of the accuracy of $\kappa M$ and $NIM$.
			The sensory neuron class is useful when experiments on the accuracy of the two simulation models are designed in chapter \ref{chExperimentalEfficiencyMeasurement}.
			Experiments can also be conducted by the reader, by declaring sensory functions with the presented format and sending the address to this function to the constructor of \emph{sensoryAuron}s. %%%%%%%%%%
			
%TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO Skriv recalk-kappa
%		\section{Recalculation of $\kappa$}
			%TODO Her skal det stå om implementation of recalculation of kappa, fra FDP.





\chapter{Other Results}
	When the activation level is below threshold, the simulated depolarization have the opportunity to level out on some value.
	This conceals the simulation error, and have therefore been excluded from the main text.
% 	This is ideal for a simulation, as it diminishes the simulation error.
	An experiment where $\kappa$ goes below the firing threshold was conducted and is included in this appendix for the sake of completeness(fig. \ref{appendixExperiment3Fig}).
% 	It has been excluded from the main report to improve readability.

	Fig. \ref{appendixDifferenceInErrorFig} shows the difference in absolute error for the second part of experiment 2, between the $NIM_{10.000}$ simulation and the $\kappa M_{100}$ simulation.
	A positive value means that the $\kappa M_{100}$ have the largest error for the corresponding spike, while a negative value means that the $NIM_{10.000}$ simulation produce the largest error.
	The cumulative property of the $NIM$ error and the stability property of the $\kappa M$ error can be observed by an increasingly negative value for the difference in absolute error.
		

\newpage
	\section{An experiment where $\kappa \in [0.5\tau, 2.5\tau]$}
		\label{appendixExperiment3Sec}

		\begin{figure}[hbt!p]
			\centerline{ \includegraphics[width=1.05\textwidth]{experiment3HalvannenPeriode} }
%			\caption{
% 			\caption[Experiment 3, sensory function $f(t)\in [0.5\tau, 2.5\tau]$]{
 			\caption[Experiment 3, where $\kappa$ varies between $0.5\tau$ and $2.5\tau$.]{
				When $\kappa$ is below the firing threshold, the depolarization value has more time to reach the final value $\kappa$.
				When comparing with fig. \ref{figExperiment2}, one can observe that the error is smaller in this experiment than in experiment 2. %this experiment produces more accurate results
				The $\kappa M$ simulation still produces more accurate results than a $NIM$ simulation with ten times the number of time steps.
				(Generated by $auroSim$)
			}
			\label{appendixExperiment3Fig}
		\end{figure}

\newpage
	\section{Difference in absolute error in experiment 2b, $NIM_{10.000}$ and $\kappa M_{100}$}
		\label{appendixDifferenceInError}
		%TODO Lag plot av sensory function where K<T avogtil.
		\begin{figure}[hbt!p]
			\centerline{ \includegraphics[width=1.1\textwidth]{diffErrorInFiringTimesTenOscillations} }
			\caption[Difference in spike time error for $NIM_{10.000}$ and $\kappa M_{100}$ in an extended run of experiment 2 (ten times as long as the forcing function in experiment 2)]{
				The difference in absolute spike time error of a $NIM_{10.000}$ simulation and a $\kappa M_{100}$ simulation for experiment 2b, $f(x) = |E_{\kappa M}| - |E_{NIM}|$ . 
				After only $150$ spikes, the $\kappa M_{100}$ simulation have a smaller error than the $NIM_{10.000}$ simulation, something that can be observed by noting that $f(x)$ becomes negative \\
					$f(x) < 0 \Leftrightarrow|E_{\kappa M}| < |E_{NIM}|$ .
				%This means that the $\kappa M$ simulation model is significantly more accurate than the $NIM$ model, as the $NIM_{10.000}$ has a number of time steps that is two orders of magnitude larger than for the $\kappa M_{100}$ simulation.
				}
			\label{appendixDifferenceInErrorFig}
		\end{figure}
\newpage
	\section{Result from `time' command, section \ref{ssecOnComputationalComlexity}}
		\label{appendixOutputOfTimeCommand}
		%TODO Lag plot av sensory function where K<T avogtil.
		\begin{figure}[hbt!p]
			\centerline{ \includegraphics[width=1.1\textwidth]{resultsFromTimeCommand} }
			\caption[Result of `time' command for ten executions of $auronSim_{KM}$ and $auroSim_{NIM}$]{
				Results of `time' command for ten runs of $auroSim_{KM}$ and $auroSim_{NIM}$, for simulations with the same temporal resolution as the simulated solution in experiment 2.
				Every second run was with $auroSim_{NIM}$ and the other was a $auroSim_{KM}$ run, in order to minimize the possibility that a global system load would effect the two models differently.
				}
		\end{figure}
		


